this is one of the most commonly asked matrix + BFS pattern problems (Leetcode #542: 01 Matrix). Itâ€™s a direct application of multi-source BFS, which is an extension of the Rotting Oranges / Number of Islands type questions â€” and a must-know for interviews at companies like Nutanix, Uber, Visa, Amazon, or Google.

Letâ€™s solve it in full interview-style, step-by-step ğŸ‘‡

ğŸ”· Problem Statement
Given an m x n binary matrix mat (containing only 0s and 1s), return a matrix dist where each cell dist[i][j] is the distance to the nearest 0.

Distance between two adjacent cells is 1 (up/down/left/right only).

ğŸ§© Example
Input:

csharp
Copy code
mat = [
  [0,0,0],
  [0,1,0],
  [1,1,1]
]
Output:

csharp
Copy code
[
  [0,0,0],
  [0,1,0],
  [1,2,1]
]
ğŸ’¬ Interview Round Simulation
Interviewer:
Youâ€™re given a binary matrix. For each 1, find the distance to the nearest 0. How would you start?

Candidate (You):
We could try BFS from each 1 to find the nearest 0, but that would be O((mn) * (mn)), too slow for big matrices.

Instead, Iâ€™ll think in reverse:

What if I start BFS from all 0s simultaneously?

Then I can propagate distance outward layer by layer.

This is known as a multi-source BFS approach.

ğŸ§  Key Idea â€” Multi-Source BFS
Treat all 0s as starting points (sources).

Initialize their distance as 0.

All 1s initially have an infinite distance (INT_MAX).

Run BFS and propagate the distance to neighbors.

ğŸ§® Algorithm
Create a queue q.

Push all coordinates of cells having 0 into q.

Maintain a dist matrix of same size.

If cell = 0, distance = 0.

Else = INT_MAX initially.

BFS:

Pop (r, c) from q.

Check all 4 directions.

If neighbor has a larger distance, update it as:

r
Copy code
dist[nr][nc] = dist[r][c] + 1
and push (nr, nc) into q.

Continue until queue is empty.

ğŸ§© Dry Run
Input:
csharp
Copy code
mat = [
  [0,0,0],
  [0,1,0],
  [1,1,1]
]
Initialization:

Queue initially = all zero cells:

css
Copy code
[(0,0), (0,1), (0,2), (1,0), (1,2)]
dist =

css
Copy code
[ [0,0,0],
  [0,âˆ,0],
  [âˆ,âˆ,âˆ] ]
Now BFS propagation ğŸ‘‡

From (0,0): neighbor (1,0) already 0 â†’ skip

From (1,0): neighbor (2,0) updated to 1

From (1,2): neighbor (2,2) updated to 1

From (2,0) or (2,2) â†’ middle (2,1) updated to 2

Also (1,1) updated to 1 (from top and sides)

Final dist =

css
Copy code
[ [0,0,0],
  [0,1,0],
  [1,2,1] ]
âœ… Matches expected output.

ğŸ§‘â€ğŸ’» Code â€” C++ (Interview-ready, clean, fully commented)
cpp
Copy code
class Solution {
public:
    vector<vector<int>> updateMatrix(vector<vector<int>>& mat) {
        int n = mat.size(), m = mat[0].size();
        vector<vector<int>> dist(n, vector<int>(m, INT_MAX));
        queue<pair<int,int>> q;

        // Step 1: Push all 0s into queue
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (mat[i][j] == 0) {
                    dist[i][j] = 0;
                    q.push({i, j});
                }
            }
        }

        // Directions: up, right, down, left
        int dr[4] = {-1, 0, 1, 0};
        int dc[4] = {0, 1, 0, -1};

        // Step 2: BFS traversal
        while (!q.empty()) {
            auto [r, c] = q.front();
            q.pop();

            for (int k = 0; k < 4; k++) {
                int nr = r + dr[k];
                int nc = c + dc[k];

                // Boundary + shorter distance check
                if (nr >= 0 && nc >= 0 && nr < n && nc < m) {
                    if (dist[nr][nc] > dist[r][c] + 1) {
                        dist[nr][nc] = dist[r][c] + 1;
                        q.push({nr, nc});
                    }
                }
            }
        }

        return dist;
    }
};
â±ï¸ Time and Space Complexity
Aspect	Complexity	Explanation
Time	O(m * n)	Each cell processed once
Space	O(m * n)	For distance matrix + queue

ğŸ” Pattern Recognition
This problem belongs to â€œMulti-source BFS on gridsâ€ â€” a super important pattern.

Youâ€™ve already seen it in:

âœ… 994. Rotting Oranges

âœ… 286. Walls and Gates

âœ… 1091. Shortest Path in Binary Matrix

âœ… 200. Number of Islands (similar traversal, but with DFS)

ğŸ¯ Tricks to Remember
Trick	Description
ğŸ’¡ Reverse Thinking	Start from zeros â†’ find distance for ones (not vice versa).
ğŸ”„ Multi-Source BFS	Push all sources (zeros) in the queue at once.
ğŸ§­ Direction Arrays	Always use {dr, dc} pattern for 4-way traversal.
ğŸš« Donâ€™t Revisit	Only push to queue when dist is updated (shorter path found).

ğŸ’¬ Follow-up Questions (for F2F / Nutanix Style)
What if diagonal moves are allowed (8 directions)?
â†’ Add 4 extra directions in the BFS.

What if instead of distance, you need the path to nearest 0?
â†’ Store parent pointers and reconstruct path.

Can you solve it using DP (two passes)?
â†’ Yes, one pass top-left to bottom-right, second bottom-right to top-left.

Would you like me to show that DP Two-Pass solution (itâ€™s often asked as a follow-up optimization question at Nutanix)?







You said:
yes


ChatGPT said:
Perfect âœ… â€” letâ€™s now go through the Dynamic Programming (DP) Two-Pass Solution for Leetcode 542 â€” 01 Matrix, just like a real Nutanix F2F round where they say:

â€œCan you do it without BFS, maybe using DP in a single or two passes?â€

ğŸ§  Interview Round 2 â€” Optimization / DP Approach
Interviewer:
Nice BFS solution!
Now suppose BFS isnâ€™t allowed â€” can you find a pure DP approach?

Candidate (You):
Yes.
If we think carefully, each cellâ€™s distance to nearest 0 depends on its neighbours.

For example, to compute dist[i][j], we can use:

ğ‘‘
ğ‘–
ğ‘ 
ğ‘¡
[
ğ‘–
]
[
ğ‘—
]
=
min
â¡
(
top
,
left
,
bottom
,
right
)
+
1
dist[i][j]=min(top,left,bottom,right)+1
But we canâ€™t get all directions in one pass â€” so we use two passes:

First pass: Top-left to bottom-right â†’ gets minimum from top and left

Second pass: Bottom-right to top-left â†’ gets minimum from bottom and right

âš™ï¸ Step-by-Step Logic
Letâ€™s break it down clearly.

Step 1ï¸âƒ£ â€” Initialize
If mat[i][j] == 0, then dist[i][j] = 0.
Else initialize as a large value (e.g., 1e9).

Step 2ï¸âƒ£ â€” Pass 1 (Top-left â†’ Bottom-right)
For each cell:

lua
Copy code
if (mat[i][j] != 0)
    dist[i][j] = min(dist[i][j],
                     min(dist[i-1][j], dist[i][j-1]) + 1)
We only check top and left neighbors (since bottom/right are not processed yet).

Step 3ï¸âƒ£ â€” Pass 2 (Bottom-right â†’ Top-left)
For each cell:

lua
Copy code
if (mat[i][j] != 0)
    dist[i][j] = min(dist[i][j],
                     min(dist[i+1][j], dist[i][j+1]) + 1)
Now we consider bottom and right neighbors.

This gives the final shortest distance.

ğŸ§© Dry Run Example
Input:

csharp
Copy code
mat = [
  [0,0,0],
  [0,1,0],
  [1,1,1]
]
Pass 1 (top-left â†’ bottom-right):
Initial dist:

css
Copy code
[ [0,0,0],
  [0,âˆ,0],
  [âˆ,âˆ,âˆ] ]
Processing row by row:

(1,1): min(top=0, left=0) + 1 = 1 â†’ dist[1][1]=1

(2,0): min(top=0,left=âˆ)+1=1

(2,1): min(top=1,left=1)+1=2

(2,2): min(top=0,left=2)+1=1

After Pass 1:

css
Copy code
[ [0,0,0],
  [0,1,0],
  [1,2,1] ]
Pass 2 (bottom-right â†’ top-left):
Nothing improves here (already minimal).

âœ… Final Answer:

css
Copy code
[ [0,0,0],
  [0,1,0],
  [1,2,1] ]
ğŸ§‘â€ğŸ’» Code â€” C++ (DP Two-Pass)
cpp
Copy code
class Solution {
public:
    vector<vector<int>> updateMatrix(vector<vector<int>>& mat) {
        int n = mat.size(), m = mat[0].size();
        vector<vector<int>> dist(n, vector<int>(m, 1e9));

        // Step 1: Initialization
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (mat[i][j] == 0)
                    dist[i][j] = 0;
            }
        }

        // Step 2: Top-left â†’ Bottom-right
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (mat[i][j] != 0) {
                    if (i > 0)
                        dist[i][j] = min(dist[i][j], dist[i - 1][j] + 1);
                    if (j > 0)
                        dist[i][j] = min(dist[i][j], dist[i][j - 1] + 1);
                }
            }
        }

        // Step 3: Bottom-right â†’ Top-left
        for (int i = n - 1; i >= 0; i--) {
            for (int j = m - 1; j >= 0; j--) {
                if (mat[i][j] != 0) {
                    if (i < n - 1)
                        dist[i][j] = min(dist[i][j], dist[i + 1][j] + 1);
                    if (j < m - 1)
                        dist[i][j] = min(dist[i][j], dist[i][j + 1] + 1);
                }
            }
        }

        return dist;
    }
};
â±ï¸ Time and Space Complexity
Aspect	Complexity	Explanation
Time	O(m * n)	Two full matrix passes
Space	O(m * n)	For the dist matrix (no queue)

ğŸ§© Comparison: BFS vs DP
Approach	Idea	Space	Advantage
BFS	Multi-source queue propagation	O(mn)	Intuitive, works for all movement types
DP Two-pass	Two directional sweeps	O(mn)	No queue, pure math, faster in practice

ğŸ§­ Pattern Insight
This â€œtwo-pass DP trickâ€ is a golden pattern for grid problems where:

Distances depend on 4-neighbor directions.

No weighted edges.

Local updates converge with two directional sweeps.

Used in:

ğŸ° 286. Walls and Gates

ğŸ§Š 329. Longest Increasing Path (DP variation)

ğŸ’¥ 64. Minimum Path Sum (one directional)

ğŸ¯ Interview Takeaway
Level	What interviewer checks
Round 1	Can you identify BFS pattern?
Round 2	Can you optimize using DP without BFS?
Round 3	Can you derive the recurrence and direction logic?
