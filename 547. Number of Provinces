Letâ€™s tackle Leetcode 547. Number of Provinces exactly the way it could appear in Nutanix / Google / Visa / Tower Research Capital interviews â€” from phone screen â†’ F2F coding â†’ debugging â†’ optimization â†’ deep-dive round.
Weâ€™ll go through it step by step so you remember both the logic and the reusable DFS/BFS/Union-Find templates.

ğŸ§© Problem: 547. Number of Provinces
Leetcode link: https://leetcode.com/problems/number-of-provinces/

ğŸ¯ Problem Statement (Interviewer-style)
Interviewer:

You are given an n x n matrix isConnected where isConnected[i][j] = 1 means there is a direct connection between city i and city j.

A province is a group of directly or indirectly connected cities with no other external connections.

Return the total number of provinces.

Example
csharp
Copy code
Input:
isConnected = [
  [1,1,0],
  [1,1,0],
  [0,0,1]
]
Output: 2
Explanation:

City 0 and 1 are connected â†’ 1 province

City 2 is isolated â†’ another province

ğŸ’­ Step 1: Clarify and Think Aloud
Candidate (you):

So, this is an undirected graph, since isConnected[i][j] == isConnected[j][i].

Each 1 represents an edge between two cities.

We need to count connected components.

ğŸ§  Step 2: Approaches Discussion (as youâ€™d do in interview)
Approach	Technique	Time	Space	Pros	Cons
1	DFS (Depth First Search)	O(NÂ²)	O(N)	Easy, Recursive	Stack depth
2	BFS	O(NÂ²)	O(N)	Iterative	Slightly more verbose
3	Union-Find (Disjoint Set)	O(NÂ² * Î±(N))	O(N)	Scalable	Slightly harder to code

ğŸ’¬ F2F Round 1: DFS Approach (Recursive)
ğŸ” Intuition
We visit every city, and if it hasnâ€™t been visited yet â€” it means it starts a new province.
We perform a DFS to mark all connected cities as visited.

ğŸ§© Dry Run
For

csharp
Copy code
[1 1 0]
[1 1 0]
[0 0 1]
Start with city 0 â†’ DFS visits {0,1} â†’ province = 1

City 1 â†’ already visited

City 2 â†’ not visited â†’ DFS visits {2} â†’ province = 2
âœ… Answer = 2

ğŸ’» C++ Code (DFS)
cpp
Copy code
class Solution {
public:
    void dfs(int node, vector<vector<int>>& isConnected, vector<int>& visited) {
        visited[node] = 1;
        for (int j = 0; j < isConnected.size(); j++) {
            // If city 'j' is connected and not yet visited
            if (isConnected[node][j] == 1 && !visited[j]) {
                dfs(j, isConnected, visited);
            }
        }
    }

    int findCircleNum(vector<vector<int>>& isConnected) {
        int n = isConnected.size();
        vector<int> visited(n, 0);
        int provinces = 0;

        for (int i = 0; i < n; i++) {
            if (!visited[i]) {
                provinces++;
                dfs(i, isConnected, visited);
            }
        }
        return provinces;
    }
};
ğŸ§© Complexity
Time: O(NÂ²) â€” each pair (i,j) is checked once.

Space: O(N) for visited + recursion stack.

ğŸ§  F2F Round 2: BFS Approach (Iterative)
ğŸ’¡ Idea
Use a queue instead of recursion â€” same logic.

ğŸ’» C++ Code (BFS)
cpp
Copy code
class Solution {
public:
    int findCircleNum(vector<vector<int>>& isConnected) {
        int n = isConnected.size();
        vector<int> visited(n, 0);
        int provinces = 0;

        for (int i = 0; i < n; i++) {
            if (!visited[i]) {
                provinces++;
                queue<int> q;
                q.push(i);
                visited[i] = 1;

                while (!q.empty()) {
                    int node = q.front(); q.pop();
                    for (int j = 0; j < n; j++) {
                        if (isConnected[node][j] == 1 && !visited[j]) {
                            visited[j] = 1;
                            q.push(j);
                        }
                    }
                }
            }
        }
        return provinces;
    }
};
ğŸ” Debugging Round (Nutanix-style)
Interviewer: "Suppose one of your test cases fails. Letâ€™s debug."

Failing input:

lua
Copy code
[[1,0,0],
 [0,1,0],
 [0,0,1]]
Expected output: 3
If your code gives 1 â†’ reason:
You likely initialized visited incorrectly or used a global visited array not reset properly.

âœ… Always reinitialize visited inside function calls.

âš™ï¸ F2F Round 3: Union-Find (Disjoint Set Union - DSU)
ğŸ§© Intuition
Each city starts in its own province (parent = itself).
Whenever two cities are connected, union them.
At the end, count unique parents.

ğŸ’» C++ Code (Union-Find)
cpp
Copy code
class Solution {
public:
    int findParent(int node, vector<int>& parent) {
        if (parent[node] == node) return node;
        return parent[node] = findParent(parent[node], parent); // path compression
    }

    void unionSet(int u, int v, vector<int>& parent, vector<int>& rank) {
        int pu = findParent(u, parent);
        int pv = findParent(v, parent);

        if (pu == pv) return;

        if (rank[pu] < rank[pv]) parent[pu] = pv;
        else if (rank[pu] > rank[pv]) parent[pv] = pu;
        else {
            parent[pv] = pu;
            rank[pu]++;
        }
    }

    int findCircleNum(vector<vector<int>>& isConnected) {
        int n = isConnected.size();
        vector<int> parent(n), rank(n, 0);
        iota(parent.begin(), parent.end(), 0);

        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                if (isConnected[i][j] == 1) {
                    unionSet(i, j, parent, rank);
                }
            }
        }

        unordered_set<int> uniqueParents;
        for (int i = 0; i < n; i++) {
            uniqueParents.insert(findParent(i, parent));
        }

        return uniqueParents.size();
    }
};
ğŸ” Complexity
Time: O(NÂ² * Î±(N)) (Î± = inverse Ackermann, ~constant)

Space: O(N)

ğŸ§© Round 4: Edge Cases
Case	Input	Output	Reason
All connected	[[1,1],[1,1]]	1	Single province
All isolated	[[1,0,0],[0,1,0],[0,0,1]]	3	No connections
Large N	200Ã—200 all 1	1	Single big province

ğŸ§© Round 5: Optimization / Follow-Up
Interviewer:

Can we use adjacency list instead of adjacency matrix?

âœ… Yes â€” if input was given as list, time would reduce to O(V + E) for DFS/BFS.

ğŸ§  Final Interviewer Notes (Pattern Recognition)
Pattern	Where Used
Counting connected components	Number of Islands, Connected Components in Graph
DFS template	Used in graphs, grids, trees
Union-Find	Used in Kruskalâ€™s MST, Redundant Connection, Accounts Merge
BFS queue traversal	Used in 0â€“1 Matrix, Word Ladder

ğŸ§© ğŸš€ Trick to Remember
â€œWhenever you are asked to count isolated groups / regions / networks â†’ Think Connected Components â†’ DFS / BFS / Union-Find.â€

Mnemonic:

"Group â†’ Graph â†’ Components â†’ Count."

âœ… Summary for Revision Sheet
Approach	Time	Space	Template Keyword
DFS	O(NÂ²)	O(N)	dfs(i) mark connected
BFS	O(NÂ²)	O(N)	queue + visited
Union-Find	O(NÂ² * Î±(N))	O(N)	findParent + unionSet
