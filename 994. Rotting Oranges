Letâ€™s do Leetcode 994. Rotting Oranges in complete interview-style â€” the way itâ€™s asked in Nutanix, Google, Visa, Tower Research Capital etc.
Weâ€™ll simulate all interview rounds â€” from problem understanding, debugging, to optimization â€” so that you never forget this pattern again.

ğŸ§© Problem: 994. Rotting Oranges

Topic: Graphs â†’ BFS (Level Order / Multi-source BFS)
Difficulty: Medium
Pattern: Multi-source BFS (Spread / Time-to-Propagate)

ğŸ¯ Problem Statement (Interviewer-style)

Interviewer:

You are given an m x n grid where each cell can have one of three values:

0 â†’ empty cell

1 â†’ fresh orange

2 â†’ rotten orange

Every minute, any fresh orange that is 4-directionally adjacent to a rotten one becomes rotten.

Return the minimum number of minutes that must elapse until no cell has a fresh orange.

If itâ€™s impossible to rot all oranges, return -1.

Example:
Input:
[[2,1,1],
 [1,1,0],
 [0,1,1]]

Output:
4


Explanation:

Minute 0 â†’ Initial grid

Minute 1 â†’ First layer of fresh oranges rot

Minute 2 â†’ Next layer rots

Minute 3 â†’ More spread

Minute 4 â†’ All oranges rotten âœ…

ğŸ§  Step 1: Clarify and Think Aloud

Candidate (you):

So, this looks like a spreading process â€” similar to BFS levels in a graph.
Each rotten orange spreads to its 4 neighbors every minute â†’ exactly like multi-source BFS.

Key Observations:

Each orange is a node in a grid graph.

Each minute = one BFS level.

We start BFS from all rotten oranges initially.

âš™ï¸ Step 2: Approach Discussion (like in a F2F coding round)
Approach	Type	Time	Space	Comment
DFS	Not suitable	Exponential	â€”	DFS canâ€™t track time layers
BFS (Multi-source)	Level order	O(mÃ—n)	O(mÃ—n)	Best approach
Simulation	Inefficient	O(kÃ—mÃ—n)	â€”	Too slow

âœ… Use BFS from all rotten oranges â†’ propagate level by level.

ğŸ§© Step 3: Dry Run on Example

Grid:

2 1 1
1 1 0
0 1 1


Initial:

Rotten = {(0,0)}

Fresh = 7

Start BFS:

Minute 0: (0,0)
â†’ Infect neighbors: (0,1), (1,0)
Minute 1: (0,1), (1,0)
â†’ Infect: (0,2), (1,1)
Minute 2: (0,2), (1,1)
â†’ Infect: (2,1)
Minute 3: (2,1)
â†’ Infect: (2,2)
Minute 4: Done.


âœ… Total = 4 minutes.

ğŸ’» Step 4: BFS Implementation (C++)
C++ Code â€” Level Order BFS (Interview Ready)
class Solution {
public:
    int orangesRotting(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size();
        queue<pair<int,int>> q;
        int fresh = 0;

        // Step 1: Push all initially rotten oranges
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 2) q.push({i, j});
                else if (grid[i][j] == 1) fresh++;
            }
        }

        // Directions: up, down, left, right
        int dx[4] = {-1, 1, 0, 0};
        int dy[4] = {0, 0, -1, 1};
        int minutes = 0;

        // Step 2: Multi-source BFS
        while (!q.empty() && fresh > 0) {
            int size = q.size();
            while (size--) {
                auto [x, y] = q.front(); q.pop();
                for (int k = 0; k < 4; k++) {
                    int nx = x + dx[k], ny = y + dy[k];
                    if (nx >= 0 && ny >= 0 && nx < m && ny < n && grid[nx][ny] == 1) {
                        grid[nx][ny] = 2; // rot it
                        fresh--;
                        q.push({nx, ny});
                    }
                }
            }
            minutes++;
        }

        return fresh == 0 ? minutes : -1;
    }
};

ğŸ§© Step 5: Dry Run (in Debugging Round)

Interviewer (Nutanix style):

Letâ€™s debug this input:
[[0,2]]

Candidate:

Only one rotten, no fresh â†’ fresh=0 â†’ directly return 0. âœ…

Another test:
[[1,0,2]] â†’ Fresh at (0,0) isolated from (0,2)
â†’ fresh remains >0 â†’ return -1. âœ…

Common bug: Forgetting to check fresh > 0 in while condition â€” might increment minutes one extra time.
âœ… Fix â†’ while (!q.empty() && fresh > 0)

ğŸ§© Step 6: Complexity Analysis

Time: O(mÃ—n) â†’ each cell visited once

Space: O(mÃ—n) â†’ queue size in worst case

ğŸ§  Step 7: Alternative / Optimization Round

Interviewer:

Can we do it without using an extra visited matrix?

Candidate:
âœ… Yes â€” we can use the grid itself to mark visited (2 = rotten).
Thatâ€™s what we did.

Interviewer:

What if we had to return the sequence of rotting instead of time?

Candidate:
Weâ€™d store time with each element in queue as {x, y, t}.

ğŸ§© Step 8: Follow-up & Related Patterns
Pattern	Question	Technique
Multi-source BFS	286. Walls and Gates	BFS from all gates
01 Matrix	542. 01 Matrix	BFS from all 0â€™s
Spread simulation	841. Keys and Rooms	BFS/DFS reachability
Flood fill	733. Flood Fill	BFS/DFS from one source

ğŸ‘‰ Trick:

If problem says â€œspreadâ€, â€œtime to infectâ€, â€œminutes to reachâ€ â†’ think multi-source BFS.

Mnemonic:

â€œSpread = BFS with Time as Levelsâ€

ğŸ§© Step 9: Edge Cases Table
Case	Input	Output	Why
All rotten	[[2,2]]	0	No fresh oranges
All fresh isolated	[[1,0,1]]	-1	Canâ€™t rot all
Empty grid	[[]]	0	No oranges
Mix	[[2,1,1],[1,1,0],[0,1,1]]	4	Standard
ğŸ§  Step 10: Final Interview Summary Sheet
Approach	Concept	Time	Space	Used in
BFS	Multi-source BFS	O(mÃ—n)	O(mÃ—n)	Oranges, Gates, Matrix Distance
DFS	Not optimal	â€”	â€”	â€”
Simulation	Naive	High	â€”	â€”
ğŸš€ Pattern Recognition

â€œRotting / Spread / Infection / Fire / Distanceâ€ â†’ Multi-source BFS

BFS levels naturally represent time.

Grid traversal always uses â†’ 4-direction arrays {dx, dy}

ğŸ§  Trick to Remember (Interview Formula)

â€œWhenever something spreads in steps â†’ Think BFS,
Whenever something spreads from many points at once â†’ Think Multi-source BFS.â€

ğŸ§© Template for Multi-source BFS
queue<pair<int,int>> q;
// push all starting sources
while (!q.empty()) {
    int sz = q.size();
    while (sz--) {
        auto [x, y] = q.front(); q.pop();
        for (auto dir : directions) {
            int nx = x + dir[0], ny = y + dir[1];
            if (valid(nx, ny) && condition) {
                q.push({nx, ny});
            }
        }
    }
    time++;
}
